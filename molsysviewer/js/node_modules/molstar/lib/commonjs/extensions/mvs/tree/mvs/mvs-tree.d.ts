/**
 * Copyright (c) 2023-2025 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Adam Midlik <midlik@gmail.com>
 * @author David Sehnal <david.sehnal@gmail.com>
 */
import { OptionalField, RequiredField } from '../generic/field-schema.js';
import { SimpleParamsSchema } from '../generic/params-schema.js';
import { NodeFor, ParamsOfKind, SubtreeOfKind, TreeFor, TreeSchema, TreeSchemaWithAllRequired } from '../generic/tree-schema.js';
import { ColorT, ComponentExpressionT, ComponentSelectorT, LabelAttachments, ParseFormatT, SchemaFormatT, SchemaT, StructureTypeT, Vector3 } from './param-types.js';
/** Color to be used e.g. for representations without 'color' node */
export declare const DefaultColor = "white";
/** Schema for `MVSTree` (MolViewSpec tree) */
export declare const MVSTreeSchema: TreeSchema<{
    root: SimpleParamsSchema<{}>;
    download: SimpleParamsSchema<{
        /** URL of the data resource. */
        url: RequiredField<string>;
    }>;
    parse: SimpleParamsSchema<{
        /** Format of the input data resource. */
        format: RequiredField<ParseFormatT>;
    }>;
    coordinates: SimpleParamsSchema<{}>;
    structure: SimpleParamsSchema<{
        /** Type of structure to be created (`"model"` for original model coordinates, `"assembly"` for assembly structure, `"symmetry"` for a set of crystal unit cells based on Miller indices, `"symmetry_mates"` for a set of asymmetric units within a radius from the original model). */
        type: RequiredField<StructureTypeT>;
        /** Header of the CIF block to read coordinates from (only applies when the input data are from CIF or BinaryCIF). If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read coordinates from (only applies when the input data are from CIF or BinaryCIF and `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** 0-based index of model in case the input data contain multiple models. */
        model_index: OptionalField<number>;
        /** Assembly identifier (only applies when `kind` is `"assembly"`). If `null`, the first assembly is selected. */
        assembly_id: OptionalField<string | null>;
        /** Distance (in Angstroms) from the original model in which asymmetric units should be included (only applies when `kind` is `"symmetry_mates"`). */
        radius: OptionalField<number>;
        /** Miller indices of the bottom-left unit cell to be included (only applies when `kind` is `"symmetry"`). */
        ijk_min: OptionalField<[number, number, number]>;
        /** Miller indices of the top-right unit cell to be included (only applies when `kind` is `"symmetry"`). */
        ijk_max: OptionalField<[number, number, number]>;
        /** Reference to a specific set of coordinates. */
        coordinates_ref: OptionalField<string | null>;
    }>;
    transform: SimpleParamsSchema<{
        /** Rotation matrix (3x3 matrix flattened in column major format (j*3+i indexing), this is equivalent to Fortran-order in numpy). This matrix will multiply the structure coordinates from the left. The default value is the identity matrix (corresponds to no rotation). */
        rotation: OptionalField<number[]>;
        /** Translation vector, applied to the structure coordinates after rotation. The default value is the zero vector (corresponds to no translation). */
        translation: OptionalField<Vector3>;
        /** Point to rotate the object around. Can be either a 3D vector or dynamically computed object centroid. */
        rotation_center: OptionalField<"centroid" | Vector3 | null>;
        /** Transform matrix (4x4 matrix flattened in column major format (j*4+i indexing), this is equivalent to Fortran-order in numpy). This matrix will multiply the structure coordinates from the left. Takes precedence over `rotation` and `translation`. */
        matrix: OptionalField<number[] | null>;
    }>;
    instance: SimpleParamsSchema<{
        /** Rotation matrix (3x3 matrix flattened in column major format (j*3+i indexing), this is equivalent to Fortran-order in numpy). This matrix will multiply the structure coordinates from the left. The default value is the identity matrix (corresponds to no rotation). */
        rotation: OptionalField<number[]>;
        /** Translation vector, applied to the structure coordinates after rotation. The default value is the zero vector (corresponds to no translation). */
        translation: OptionalField<Vector3>;
        /** Point to rotate the object around. Can be either a 3D vector or dynamically computed object centroid. */
        rotation_center: OptionalField<"centroid" | Vector3 | null>;
        /** Transform matrix (4x4 matrix flattened in column major format (j*4+i indexing), this is equivalent to Fortran-order in numpy). This matrix will multiply the structure coordinates from the left. Takes precedence over `rotation` and `translation`. */
        matrix: OptionalField<number[] | null>;
    }>;
    component: SimpleParamsSchema<{
        /** Defines what part of the parent structure should be included in this component. */
        selector: RequiredField<ComponentSelectorT | ComponentExpressionT | ComponentExpressionT[]>;
    }>;
    component_from_uri: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the component identifier. */
        field_name: OptionalField<string>;
        /** List of component identifiers (i.e. values in the field given by `field_name`) which should be included in this component. If `null`, component identifiers are ignored (all annotation rows are included), and `field_name` field can be dropped from the annotation. */
        field_values: OptionalField<string[] | null>;
        /** URL of the annotation resource. */
        uri: RequiredField<string>;
        /** Format of the annotation resource. */
        format: RequiredField<SchemaFormatT>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"` and `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    component_from_source: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the component identifier. */
        field_name: OptionalField<string>;
        /** List of component identifiers (i.e. values in the field given by `field_name`) which should be included in this component. If `null`, component identifiers are ignored (all annotation rows are included), and `field_name` field can be dropped from the annotation. */
        field_values: OptionalField<string[] | null>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from. If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from. If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    representation: import("../generic/params-schema.js").UnionParamsSchema<"type", {
        cartoon: SimpleParamsSchema<{
            size_factor: OptionalField<number>;
            tubular_helices: OptionalField<boolean>;
        }>;
        backbone: SimpleParamsSchema<{
            size_factor: OptionalField<number>;
        }>;
        ball_and_stick: SimpleParamsSchema<{
            size_factor: OptionalField<number>;
            ignore_hydrogens: OptionalField<boolean>;
        }>;
        line: SimpleParamsSchema<{
            size_factor: OptionalField<number>;
            ignore_hydrogens: OptionalField<boolean>;
        }>;
        spacefill: SimpleParamsSchema<{
            size_factor: OptionalField<number>;
            ignore_hydrogens: OptionalField<boolean>;
        }>;
        carbohydrate: SimpleParamsSchema<{
            size_factor: OptionalField<number>;
        }>;
        surface: SimpleParamsSchema<{
            surface_type: OptionalField<"gaussian" | "molecular">;
            size_factor: OptionalField<number>;
            ignore_hydrogens: OptionalField<boolean>;
        }>;
    }>;
    volume: SimpleParamsSchema<{
        /** Channel identifier (only applies when the input data contain multiple channels). */
        channel_id: OptionalField<string | null>;
    }>;
    volume_representation: import("../generic/params-schema.js").UnionParamsSchema<"type", {
        isosurface: SimpleParamsSchema<{
            relative_isovalue: OptionalField<number | null>;
            absolute_isovalue: OptionalField<number | null>;
            show_wireframe: OptionalField<boolean>;
            show_faces: OptionalField<boolean>;
        }>;
        grid_slice: SimpleParamsSchema<{
            dimension: RequiredField<"x" | "y" | "z">;
            absolute_index: OptionalField<number | null>;
            relative_index: OptionalField<number | null>;
            relative_isovalue: OptionalField<number | null>;
            absolute_isovalue: OptionalField<number | null>;
        }>;
    }>;
    color: SimpleParamsSchema<{
        /** Color to apply to the representation. Can be either an X11 color name (e.g. `"red"`) or a hexadecimal code (e.g. `"#FF0011"`). */
        color: OptionalField<ColorT>;
        /** Defines to what part of the representation this color should be applied. */
        selector: OptionalField<ComponentSelectorT | ComponentExpressionT | ComponentExpressionT[]>;
    }>;
    color_from_uri: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the color. */
        field_name: OptionalField<string>;
        /** Customize mapping of annotation values to colors. */
        palette: OptionalField<import("./param-types.js").CategoricalPalette | import("./param-types.js").DiscretePalette | import("./param-types.js").ContinuousPalette | null>;
        /** URL of the annotation resource. */
        uri: RequiredField<string>;
        /** Format of the annotation resource. */
        format: RequiredField<SchemaFormatT>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"` and `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    color_from_source: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the color. */
        field_name: OptionalField<string>;
        /** Customize mapping of annotation values to colors. */
        palette: OptionalField<import("./param-types.js").CategoricalPalette | import("./param-types.js").DiscretePalette | import("./param-types.js").ContinuousPalette | null>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from. If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from. If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    clip: import("../generic/params-schema.js").UnionParamsSchema<"type", {
        plane: SimpleParamsSchema<{
            normal: RequiredField<Vector3>;
            point: RequiredField<Vector3>;
            check_transform: OptionalField<number[] | null>;
            invert: OptionalField<boolean>;
            variant: OptionalField<"object" | "pixel">;
        }>;
        sphere: SimpleParamsSchema<{
            center: RequiredField<Vector3>;
            radius: OptionalField<number>;
            check_transform: OptionalField<number[] | null>;
            invert: OptionalField<boolean>;
            variant: OptionalField<"object" | "pixel">;
        }>;
        box: SimpleParamsSchema<{
            center: RequiredField<Vector3>;
            size: OptionalField<Vector3>;
            rotation: OptionalField<number[]>;
            check_transform: OptionalField<number[] | null>;
            invert: OptionalField<boolean>;
            variant: OptionalField<"object" | "pixel">;
        }>;
    }>;
    opacity: SimpleParamsSchema<{
        /** Opacity of a representation. 0.0: fully transparent, 1.0: fully opaque. */
        opacity: RequiredField<number>;
    }>;
    label: SimpleParamsSchema<{
        /** Content of the shown label. */
        text: RequiredField<string>;
    }>;
    label_from_uri: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the label text. */
        field_name: OptionalField<string>;
        /** URL of the annotation resource. */
        uri: RequiredField<string>;
        /** Format of the annotation resource. */
        format: RequiredField<SchemaFormatT>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"` and `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    label_from_source: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the label text. */
        field_name: OptionalField<string>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from. If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from. If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    tooltip: SimpleParamsSchema<{
        /** Content of the shown tooltip. */
        text: RequiredField<string>;
    }>;
    tooltip_from_uri: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the tooltip text. */
        field_name: OptionalField<string>;
        /** URL of the annotation resource. */
        uri: RequiredField<string>;
        /** Format of the annotation resource. */
        format: RequiredField<SchemaFormatT>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"` and `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    tooltip_from_source: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the tooltip text. */
        field_name: OptionalField<string>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from. If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from. If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    focus: SimpleParamsSchema<{
        /** Vector describing the direction of the view (camera position -> focused target). */
        direction: OptionalField<Vector3>;
        /** Vector which will be aligned with the screen Y axis. */
        up: OptionalField<Vector3>;
        /** Radius of the focused sphere (overrides `radius_factor` and `radius_extra`. */
        radius: OptionalField<number | null>;
        /** Radius of the focused sphere relative to the radius of parent component (default: 1). Focused radius = component_radius * radius_factor + radius_extent. */
        radius_factor: OptionalField<number>;
        /** Addition to the radius of the focused sphere, if computed from the radius of parent component (default: 0). Focused radius = component_radius * radius_factor + radius_extent. */
        radius_extent: OptionalField<number>;
    }>;
    camera: SimpleParamsSchema<{
        /** Coordinates of the point in space at which the camera is pointing. */
        target: RequiredField<Vector3>;
        /** Coordinates of the camera. */
        position: RequiredField<Vector3>;
        /** Vector which will be aligned with the screen Y axis. */
        up: OptionalField<Vector3>;
        /** Near clipping plane distance from the position. */
        near: OptionalField<number | null>;
    }>;
    canvas: SimpleParamsSchema<{
        /** Color of the canvas background. Can be either an X11 color name (e.g. `"red"`) or a hexadecimal code (e.g. `"#FF0011"`). */
        background_color: OptionalField<ColorT>;
    }>;
    primitives: SimpleParamsSchema<{
        /** Default color for primitives in this group. */
        color: OptionalField<ColorT>;
        /** Default label color for primitives in this group. */
        label_color: OptionalField<ColorT>;
        /** Default tooltip for primitives in this group. */
        tooltip: OptionalField<string | null>;
        /** Opacity of primitive geometry in this group. */
        opacity: OptionalField<number>;
        /** Opacity of primitive labels in this group. */
        label_opacity: OptionalField<number>;
        /** Whether to show a tether line between the label and the target. Defaults to false. */
        label_show_tether: OptionalField<boolean>;
        /** Length of the tether line between the label and the target. Defaults to 1 (Angstrom). */
        label_tether_length: OptionalField<number>;
        /** How to attach the label to the target. Defaults to "middle-center". */
        label_attachment: OptionalField<LabelAttachments>;
        /** Background color of the label. Defaults to none/transparent. */
        label_background_color: OptionalField<ColorT | null>;
        /** Load snapshot with the provided key when interacting with this primitives group. */
        snapshot_key: OptionalField<string | null>;
        /** Instances of this primitive group defined as 4x4 column major (j * 4 + i indexing) transformation matrices. */
        instances: OptionalField<number[][] | null>;
    }>;
    primitives_from_uri: SimpleParamsSchema<{
        /** Location of the resource. */
        uri: RequiredField<string>;
        /** Format of the data. */
        format: RequiredField<"mvs-node-json">;
        /** List of nodes the data are referencing. */
        references: OptionalField<string[]>;
    }>;
    primitive: import("../generic/params-schema.js").UnionParamsSchema<"kind", {
        mesh: SimpleParamsSchema<{
            vertices: RequiredField<number[]>;
            indices: RequiredField<number[]>;
            triangle_groups: OptionalField<number[] | null>;
            group_colors: OptionalField<{
                [x: number]: ColorT;
            }>;
            group_tooltips: OptionalField<{
                [x: number]: string;
            }>;
            color: OptionalField<ColorT | null>;
            tooltip: OptionalField<string | null>;
            show_triangles: OptionalField<boolean>;
            show_wireframe: OptionalField<boolean>;
            wireframe_width: OptionalField<number>;
            wireframe_color: OptionalField<ColorT | null>;
        }>;
        lines: SimpleParamsSchema<{
            vertices: RequiredField<number[]>;
            indices: RequiredField<number[]>;
            line_groups: OptionalField<number[] | null>;
            group_colors: OptionalField<{
                [x: number]: ColorT;
            }>;
            group_tooltips: OptionalField<{
                [x: number]: string;
            }>;
            group_widths: OptionalField<{
                [x: number]: number;
            }>;
            color: OptionalField<ColorT | null>;
            tooltip: OptionalField<string | null>;
            width: OptionalField<number>;
        }>;
        tube: SimpleParamsSchema<{
            tooltip: OptionalField<string | null>;
            start: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            end: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            radius: OptionalField<number>;
            dash_length: OptionalField<number | null>;
            color: OptionalField<ColorT | null>;
        }>;
        arrow: SimpleParamsSchema<{
            start: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            end: OptionalField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT | null>;
            direction: OptionalField<Vector3 | null>;
            length: OptionalField<number | null>;
            show_start_cap: OptionalField<boolean>;
            start_cap_length: OptionalField<number | null>;
            start_cap_radius: OptionalField<number | null>;
            show_end_cap: OptionalField<boolean>;
            end_cap_length: OptionalField<number | null>;
            end_cap_radius: OptionalField<number | null>;
            show_tube: OptionalField<boolean>;
            tube_radius: OptionalField<number>;
            tube_dash_length: OptionalField<number | null>;
            color: OptionalField<ColorT | null>;
            tooltip: OptionalField<string | null>;
        }>;
        distance_measurement: SimpleParamsSchema<{
            label_template: OptionalField<string>;
            label_size: OptionalField<number | null>;
            label_auto_size_scale: OptionalField<number>;
            label_auto_size_min: OptionalField<number>;
            label_color: OptionalField<ColorT | null>;
            start: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            end: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            radius: OptionalField<number>;
            dash_length: OptionalField<number | null>;
            color: OptionalField<ColorT | null>;
        }>;
        angle_measurement: SimpleParamsSchema<{
            a: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            b: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            c: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            label_template: OptionalField<string>;
            label_size: OptionalField<number | null>;
            label_auto_size_scale: OptionalField<number>;
            label_auto_size_min: OptionalField<number>;
            label_color: OptionalField<ColorT | null>;
            show_vector: OptionalField<boolean>;
            vector_color: OptionalField<ColorT | null>;
            vector_radius: OptionalField<number>;
            show_section: OptionalField<boolean>;
            section_color: OptionalField<ColorT | null>;
            section_radius: OptionalField<number | null>;
            section_radius_scale: OptionalField<number>;
        }>;
        label: SimpleParamsSchema<{
            position: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            text: RequiredField<string>;
            label_size: OptionalField<number>;
            label_color: OptionalField<ColorT | null>;
            label_offset: OptionalField<number>;
        }>;
        ellipse: SimpleParamsSchema<{
            color: OptionalField<ColorT | null>;
            as_circle: OptionalField<boolean>;
            center: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            major_axis: OptionalField<Vector3 | null>;
            minor_axis: OptionalField<Vector3 | null>;
            major_axis_endpoint: OptionalField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT | null>;
            minor_axis_endpoint: OptionalField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT | null>;
            radius_major: OptionalField<number | null>;
            radius_minor: OptionalField<number | null>;
            theta_start: OptionalField<number>;
            theta_end: OptionalField<number>;
            tooltip: OptionalField<string | null>;
        }>;
        ellipsoid: SimpleParamsSchema<{
            color: OptionalField<ColorT | null>;
            center: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            major_axis: OptionalField<Vector3 | null>;
            minor_axis: OptionalField<Vector3 | null>;
            major_axis_endpoint: OptionalField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT | null>;
            minor_axis_endpoint: OptionalField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT | null>;
            radius: OptionalField<number | Vector3 | null>;
            radius_extent: OptionalField<number | Vector3 | null>;
            tooltip: OptionalField<string | null>;
        }>;
        box: SimpleParamsSchema<{
            center: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            extent: OptionalField<Vector3 | null>;
            show_faces: OptionalField<boolean>;
            face_color: OptionalField<ColorT | null>;
            show_edges: OptionalField<boolean>;
            edge_radius: OptionalField<number>;
            edge_color: OptionalField<ColorT | null>;
            tooltip: OptionalField<string | null>;
        }>;
    }>;
}, "root">;
/** Node kind in a `MVSTree` */
export type MVSKind = keyof typeof MVSTreeSchema.nodes;
/** Node in a `MVSTree` */
export type MVSNode<TKind extends MVSKind = MVSKind> = NodeFor<typeof MVSTreeSchema, TKind>;
/** Params for a specific node kind in a `MVSTree` */
export type MVSNodeParams<TKind extends MVSKind> = ParamsOfKind<MVSTree, TKind>;
/** MolViewSpec tree */
export type MVSTree = TreeFor<typeof MVSTreeSchema>;
/** Any subtree in a `MVSTree` (e.g. its root doesn't need to be 'root') */
export type MVSSubtree<TKind extends MVSKind = MVSKind> = SubtreeOfKind<MVSTree, TKind>;
/** Schema for `MVSTree` (MolViewSpec tree with all params provided) */
export declare const FullMVSTreeSchema: TreeSchemaWithAllRequired<TreeSchema<{
    root: SimpleParamsSchema<{}>;
    download: SimpleParamsSchema<{
        /** URL of the data resource. */
        url: RequiredField<string>;
    }>;
    parse: SimpleParamsSchema<{
        /** Format of the input data resource. */
        format: RequiredField<ParseFormatT>;
    }>;
    coordinates: SimpleParamsSchema<{}>;
    structure: SimpleParamsSchema<{
        /** Type of structure to be created (`"model"` for original model coordinates, `"assembly"` for assembly structure, `"symmetry"` for a set of crystal unit cells based on Miller indices, `"symmetry_mates"` for a set of asymmetric units within a radius from the original model). */
        type: RequiredField<StructureTypeT>;
        /** Header of the CIF block to read coordinates from (only applies when the input data are from CIF or BinaryCIF). If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read coordinates from (only applies when the input data are from CIF or BinaryCIF and `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** 0-based index of model in case the input data contain multiple models. */
        model_index: OptionalField<number>;
        /** Assembly identifier (only applies when `kind` is `"assembly"`). If `null`, the first assembly is selected. */
        assembly_id: OptionalField<string | null>;
        /** Distance (in Angstroms) from the original model in which asymmetric units should be included (only applies when `kind` is `"symmetry_mates"`). */
        radius: OptionalField<number>;
        /** Miller indices of the bottom-left unit cell to be included (only applies when `kind` is `"symmetry"`). */
        ijk_min: OptionalField<[number, number, number]>;
        /** Miller indices of the top-right unit cell to be included (only applies when `kind` is `"symmetry"`). */
        ijk_max: OptionalField<[number, number, number]>;
        /** Reference to a specific set of coordinates. */
        coordinates_ref: OptionalField<string | null>;
    }>;
    transform: SimpleParamsSchema<{
        /** Rotation matrix (3x3 matrix flattened in column major format (j*3+i indexing), this is equivalent to Fortran-order in numpy). This matrix will multiply the structure coordinates from the left. The default value is the identity matrix (corresponds to no rotation). */
        rotation: OptionalField<number[]>;
        /** Translation vector, applied to the structure coordinates after rotation. The default value is the zero vector (corresponds to no translation). */
        translation: OptionalField<Vector3>;
        /** Point to rotate the object around. Can be either a 3D vector or dynamically computed object centroid. */
        rotation_center: OptionalField<"centroid" | Vector3 | null>;
        /** Transform matrix (4x4 matrix flattened in column major format (j*4+i indexing), this is equivalent to Fortran-order in numpy). This matrix will multiply the structure coordinates from the left. Takes precedence over `rotation` and `translation`. */
        matrix: OptionalField<number[] | null>;
    }>;
    instance: SimpleParamsSchema<{
        /** Rotation matrix (3x3 matrix flattened in column major format (j*3+i indexing), this is equivalent to Fortran-order in numpy). This matrix will multiply the structure coordinates from the left. The default value is the identity matrix (corresponds to no rotation). */
        rotation: OptionalField<number[]>;
        /** Translation vector, applied to the structure coordinates after rotation. The default value is the zero vector (corresponds to no translation). */
        translation: OptionalField<Vector3>;
        /** Point to rotate the object around. Can be either a 3D vector or dynamically computed object centroid. */
        rotation_center: OptionalField<"centroid" | Vector3 | null>;
        /** Transform matrix (4x4 matrix flattened in column major format (j*4+i indexing), this is equivalent to Fortran-order in numpy). This matrix will multiply the structure coordinates from the left. Takes precedence over `rotation` and `translation`. */
        matrix: OptionalField<number[] | null>;
    }>;
    component: SimpleParamsSchema<{
        /** Defines what part of the parent structure should be included in this component. */
        selector: RequiredField<ComponentSelectorT | ComponentExpressionT | ComponentExpressionT[]>;
    }>;
    component_from_uri: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the component identifier. */
        field_name: OptionalField<string>;
        /** List of component identifiers (i.e. values in the field given by `field_name`) which should be included in this component. If `null`, component identifiers are ignored (all annotation rows are included), and `field_name` field can be dropped from the annotation. */
        field_values: OptionalField<string[] | null>;
        /** URL of the annotation resource. */
        uri: RequiredField<string>;
        /** Format of the annotation resource. */
        format: RequiredField<SchemaFormatT>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"` and `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    component_from_source: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the component identifier. */
        field_name: OptionalField<string>;
        /** List of component identifiers (i.e. values in the field given by `field_name`) which should be included in this component. If `null`, component identifiers are ignored (all annotation rows are included), and `field_name` field can be dropped from the annotation. */
        field_values: OptionalField<string[] | null>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from. If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from. If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    representation: import("../generic/params-schema.js").UnionParamsSchema<"type", {
        cartoon: SimpleParamsSchema<{
            size_factor: OptionalField<number>;
            tubular_helices: OptionalField<boolean>;
        }>;
        backbone: SimpleParamsSchema<{
            size_factor: OptionalField<number>;
        }>;
        ball_and_stick: SimpleParamsSchema<{
            size_factor: OptionalField<number>;
            ignore_hydrogens: OptionalField<boolean>;
        }>;
        line: SimpleParamsSchema<{
            size_factor: OptionalField<number>;
            ignore_hydrogens: OptionalField<boolean>;
        }>;
        spacefill: SimpleParamsSchema<{
            size_factor: OptionalField<number>;
            ignore_hydrogens: OptionalField<boolean>;
        }>;
        carbohydrate: SimpleParamsSchema<{
            size_factor: OptionalField<number>;
        }>;
        surface: SimpleParamsSchema<{
            surface_type: OptionalField<"gaussian" | "molecular">;
            size_factor: OptionalField<number>;
            ignore_hydrogens: OptionalField<boolean>;
        }>;
    }>;
    volume: SimpleParamsSchema<{
        /** Channel identifier (only applies when the input data contain multiple channels). */
        channel_id: OptionalField<string | null>;
    }>;
    volume_representation: import("../generic/params-schema.js").UnionParamsSchema<"type", {
        isosurface: SimpleParamsSchema<{
            relative_isovalue: OptionalField<number | null>;
            absolute_isovalue: OptionalField<number | null>;
            show_wireframe: OptionalField<boolean>;
            show_faces: OptionalField<boolean>;
        }>;
        grid_slice: SimpleParamsSchema<{
            dimension: RequiredField<"x" | "y" | "z">;
            absolute_index: OptionalField<number | null>;
            relative_index: OptionalField<number | null>;
            relative_isovalue: OptionalField<number | null>;
            absolute_isovalue: OptionalField<number | null>;
        }>;
    }>;
    color: SimpleParamsSchema<{
        /** Color to apply to the representation. Can be either an X11 color name (e.g. `"red"`) or a hexadecimal code (e.g. `"#FF0011"`). */
        color: OptionalField<ColorT>;
        /** Defines to what part of the representation this color should be applied. */
        selector: OptionalField<ComponentSelectorT | ComponentExpressionT | ComponentExpressionT[]>;
    }>;
    color_from_uri: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the color. */
        field_name: OptionalField<string>;
        /** Customize mapping of annotation values to colors. */
        palette: OptionalField<import("./param-types.js").CategoricalPalette | import("./param-types.js").DiscretePalette | import("./param-types.js").ContinuousPalette | null>;
        /** URL of the annotation resource. */
        uri: RequiredField<string>;
        /** Format of the annotation resource. */
        format: RequiredField<SchemaFormatT>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"` and `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    color_from_source: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the color. */
        field_name: OptionalField<string>;
        /** Customize mapping of annotation values to colors. */
        palette: OptionalField<import("./param-types.js").CategoricalPalette | import("./param-types.js").DiscretePalette | import("./param-types.js").ContinuousPalette | null>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from. If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from. If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    clip: import("../generic/params-schema.js").UnionParamsSchema<"type", {
        plane: SimpleParamsSchema<{
            normal: RequiredField<Vector3>;
            point: RequiredField<Vector3>;
            check_transform: OptionalField<number[] | null>;
            invert: OptionalField<boolean>;
            variant: OptionalField<"object" | "pixel">;
        }>;
        sphere: SimpleParamsSchema<{
            center: RequiredField<Vector3>;
            radius: OptionalField<number>;
            check_transform: OptionalField<number[] | null>;
            invert: OptionalField<boolean>;
            variant: OptionalField<"object" | "pixel">;
        }>;
        box: SimpleParamsSchema<{
            center: RequiredField<Vector3>;
            size: OptionalField<Vector3>;
            rotation: OptionalField<number[]>;
            check_transform: OptionalField<number[] | null>;
            invert: OptionalField<boolean>;
            variant: OptionalField<"object" | "pixel">;
        }>;
    }>;
    opacity: SimpleParamsSchema<{
        /** Opacity of a representation. 0.0: fully transparent, 1.0: fully opaque. */
        opacity: RequiredField<number>;
    }>;
    label: SimpleParamsSchema<{
        /** Content of the shown label. */
        text: RequiredField<string>;
    }>;
    label_from_uri: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the label text. */
        field_name: OptionalField<string>;
        /** URL of the annotation resource. */
        uri: RequiredField<string>;
        /** Format of the annotation resource. */
        format: RequiredField<SchemaFormatT>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"` and `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    label_from_source: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the label text. */
        field_name: OptionalField<string>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from. If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from. If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    tooltip: SimpleParamsSchema<{
        /** Content of the shown tooltip. */
        text: RequiredField<string>;
    }>;
    tooltip_from_uri: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the tooltip text. */
        field_name: OptionalField<string>;
        /** URL of the annotation resource. */
        uri: RequiredField<string>;
        /** Format of the annotation resource. */
        format: RequiredField<SchemaFormatT>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `format` is `"cif"` or `"bcif"` and `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from (only applies when `format` is `"cif"` or `"bcif"`). If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    tooltip_from_source: SimpleParamsSchema<{
        /** Name of the column in CIF or field name (key) in JSON that contains the tooltip text. */
        field_name: OptionalField<string>;
        /** Annotation schema defines what fields in the annotation will be taken into account. */
        schema: RequiredField<SchemaT>;
        /** Header of the CIF block to read annotation from. If `null`, block is selected based on `block_index`. */
        block_header: OptionalField<string | null>;
        /** 0-based index of the CIF block to read annotation from (only applies when `block_header` is `null`). */
        block_index: OptionalField<number>;
        /** Name of the CIF category to read annotation from. If `null`, the first category in the block is used. */
        category_name: OptionalField<string | null>;
        /** Optional remapping of annotation field names `{ standardName1: actualName1, ... }`. Use `{ "label_asym_id": "X" }` to load actual field "X" as "label_asym_id". Use `{ "label_asym_id": null }` to ignore actual field "label_asym_id". Fields not mentioned here are mapped implicitely (i.e. actual name = standard name). */
        field_remapping: OptionalField<{
            [x: string]: string | null;
        }>;
    }>;
    focus: SimpleParamsSchema<{
        /** Vector describing the direction of the view (camera position -> focused target). */
        direction: OptionalField<Vector3>;
        /** Vector which will be aligned with the screen Y axis. */
        up: OptionalField<Vector3>;
        /** Radius of the focused sphere (overrides `radius_factor` and `radius_extra`. */
        radius: OptionalField<number | null>;
        /** Radius of the focused sphere relative to the radius of parent component (default: 1). Focused radius = component_radius * radius_factor + radius_extent. */
        radius_factor: OptionalField<number>;
        /** Addition to the radius of the focused sphere, if computed from the radius of parent component (default: 0). Focused radius = component_radius * radius_factor + radius_extent. */
        radius_extent: OptionalField<number>;
    }>;
    camera: SimpleParamsSchema<{
        /** Coordinates of the point in space at which the camera is pointing. */
        target: RequiredField<Vector3>;
        /** Coordinates of the camera. */
        position: RequiredField<Vector3>;
        /** Vector which will be aligned with the screen Y axis. */
        up: OptionalField<Vector3>;
        /** Near clipping plane distance from the position. */
        near: OptionalField<number | null>;
    }>;
    canvas: SimpleParamsSchema<{
        /** Color of the canvas background. Can be either an X11 color name (e.g. `"red"`) or a hexadecimal code (e.g. `"#FF0011"`). */
        background_color: OptionalField<ColorT>;
    }>;
    primitives: SimpleParamsSchema<{
        /** Default color for primitives in this group. */
        color: OptionalField<ColorT>;
        /** Default label color for primitives in this group. */
        label_color: OptionalField<ColorT>;
        /** Default tooltip for primitives in this group. */
        tooltip: OptionalField<string | null>;
        /** Opacity of primitive geometry in this group. */
        opacity: OptionalField<number>;
        /** Opacity of primitive labels in this group. */
        label_opacity: OptionalField<number>;
        /** Whether to show a tether line between the label and the target. Defaults to false. */
        label_show_tether: OptionalField<boolean>;
        /** Length of the tether line between the label and the target. Defaults to 1 (Angstrom). */
        label_tether_length: OptionalField<number>;
        /** How to attach the label to the target. Defaults to "middle-center". */
        label_attachment: OptionalField<LabelAttachments>;
        /** Background color of the label. Defaults to none/transparent. */
        label_background_color: OptionalField<ColorT | null>;
        /** Load snapshot with the provided key when interacting with this primitives group. */
        snapshot_key: OptionalField<string | null>;
        /** Instances of this primitive group defined as 4x4 column major (j * 4 + i indexing) transformation matrices. */
        instances: OptionalField<number[][] | null>;
    }>;
    primitives_from_uri: SimpleParamsSchema<{
        /** Location of the resource. */
        uri: RequiredField<string>;
        /** Format of the data. */
        format: RequiredField<"mvs-node-json">;
        /** List of nodes the data are referencing. */
        references: OptionalField<string[]>;
    }>;
    primitive: import("../generic/params-schema.js").UnionParamsSchema<"kind", {
        mesh: SimpleParamsSchema<{
            vertices: RequiredField<number[]>;
            indices: RequiredField<number[]>;
            triangle_groups: OptionalField<number[] | null>;
            group_colors: OptionalField<{
                [x: number]: ColorT;
            }>;
            group_tooltips: OptionalField<{
                [x: number]: string;
            }>;
            color: OptionalField<ColorT | null>;
            tooltip: OptionalField<string | null>;
            show_triangles: OptionalField<boolean>;
            show_wireframe: OptionalField<boolean>;
            wireframe_width: OptionalField<number>;
            wireframe_color: OptionalField<ColorT | null>;
        }>;
        lines: SimpleParamsSchema<{
            vertices: RequiredField<number[]>;
            indices: RequiredField<number[]>;
            line_groups: OptionalField<number[] | null>;
            group_colors: OptionalField<{
                [x: number]: ColorT;
            }>;
            group_tooltips: OptionalField<{
                [x: number]: string;
            }>;
            group_widths: OptionalField<{
                [x: number]: number;
            }>;
            color: OptionalField<ColorT | null>;
            tooltip: OptionalField<string | null>;
            width: OptionalField<number>;
        }>;
        tube: SimpleParamsSchema<{
            tooltip: OptionalField<string | null>;
            start: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            end: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            radius: OptionalField<number>;
            dash_length: OptionalField<number | null>;
            color: OptionalField<ColorT | null>;
        }>;
        arrow: SimpleParamsSchema<{
            start: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            end: OptionalField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT | null>;
            direction: OptionalField<Vector3 | null>;
            length: OptionalField<number | null>;
            show_start_cap: OptionalField<boolean>;
            start_cap_length: OptionalField<number | null>;
            start_cap_radius: OptionalField<number | null>;
            show_end_cap: OptionalField<boolean>;
            end_cap_length: OptionalField<number | null>;
            end_cap_radius: OptionalField<number | null>;
            show_tube: OptionalField<boolean>;
            tube_radius: OptionalField<number>;
            tube_dash_length: OptionalField<number | null>;
            color: OptionalField<ColorT | null>;
            tooltip: OptionalField<string | null>;
        }>;
        distance_measurement: SimpleParamsSchema<{
            label_template: OptionalField<string>;
            label_size: OptionalField<number | null>;
            label_auto_size_scale: OptionalField<number>;
            label_auto_size_min: OptionalField<number>;
            label_color: OptionalField<ColorT | null>;
            start: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            end: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            radius: OptionalField<number>;
            dash_length: OptionalField<number | null>;
            color: OptionalField<ColorT | null>;
        }>;
        angle_measurement: SimpleParamsSchema<{
            a: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            b: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            c: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            label_template: OptionalField<string>;
            label_size: OptionalField<number | null>;
            label_auto_size_scale: OptionalField<number>;
            label_auto_size_min: OptionalField<number>;
            label_color: OptionalField<ColorT | null>;
            show_vector: OptionalField<boolean>;
            vector_color: OptionalField<ColorT | null>;
            vector_radius: OptionalField<number>;
            show_section: OptionalField<boolean>;
            section_color: OptionalField<ColorT | null>;
            section_radius: OptionalField<number | null>;
            section_radius_scale: OptionalField<number>;
        }>;
        label: SimpleParamsSchema<{
            position: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            text: RequiredField<string>;
            label_size: OptionalField<number>;
            label_color: OptionalField<ColorT | null>;
            label_offset: OptionalField<number>;
        }>;
        ellipse: SimpleParamsSchema<{
            color: OptionalField<ColorT | null>;
            as_circle: OptionalField<boolean>;
            center: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            major_axis: OptionalField<Vector3 | null>;
            minor_axis: OptionalField<Vector3 | null>;
            major_axis_endpoint: OptionalField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT | null>;
            minor_axis_endpoint: OptionalField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT | null>;
            radius_major: OptionalField<number | null>;
            radius_minor: OptionalField<number | null>;
            theta_start: OptionalField<number>;
            theta_end: OptionalField<number>;
            tooltip: OptionalField<string | null>;
        }>;
        ellipsoid: SimpleParamsSchema<{
            color: OptionalField<ColorT | null>;
            center: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            major_axis: OptionalField<Vector3 | null>;
            minor_axis: OptionalField<Vector3 | null>;
            major_axis_endpoint: OptionalField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT | null>;
            minor_axis_endpoint: OptionalField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT | null>;
            radius: OptionalField<number | Vector3 | null>;
            radius_extent: OptionalField<number | Vector3 | null>;
            tooltip: OptionalField<string | null>;
        }>;
        box: SimpleParamsSchema<{
            center: RequiredField<ComponentExpressionT | Vector3 | import("./param-types.js").PrimitiveComponentExpressionT>;
            extent: OptionalField<Vector3 | null>;
            show_faces: OptionalField<boolean>;
            face_color: OptionalField<ColorT | null>;
            show_edges: OptionalField<boolean>;
            edge_radius: OptionalField<number>;
            edge_color: OptionalField<ColorT | null>;
            tooltip: OptionalField<string | null>;
        }>;
    }>;
}, "root">>;
/** MolViewSpec tree with all params provided */
export type FullMVSTree = TreeFor<typeof FullMVSTreeSchema>;
