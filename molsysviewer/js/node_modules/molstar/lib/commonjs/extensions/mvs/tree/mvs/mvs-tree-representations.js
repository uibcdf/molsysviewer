"use strict";
/**
 * Copyright (c) 2025 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MVSClipParams = exports.MVSVolumeRepresentationParams = exports.MVSRepresentationParams = void 0;
const field_schema_1 = require("../generic/field-schema.js");
const params_schema_1 = require("../generic/params-schema.js");
const param_types_1 = require("./param-types.js");
const Cartoon = {
    /** Scales the corresponding visuals */
    size_factor: (0, field_schema_1.OptionalField)(field_schema_1.float, 1, 'Scales the corresponding visuals.'),
    /** Simplify corkscrew helices to tubes. */
    tubular_helices: (0, field_schema_1.OptionalField)(field_schema_1.bool, false, 'Simplify corkscrew helices to tubes.'),
};
const Backbone = {
    /** Scales the corresponding visuals */
    size_factor: (0, field_schema_1.OptionalField)(field_schema_1.float, 1, 'Scales the corresponding visuals.'),
};
const BallAndStick = {
    /** Scales the corresponding visuals */
    size_factor: (0, field_schema_1.OptionalField)(field_schema_1.float, 1, 'Scales the corresponding visuals.'),
    /** Controls whether hydrogen atoms are drawn. */
    ignore_hydrogens: (0, field_schema_1.OptionalField)(field_schema_1.bool, false, 'Controls whether hydrogen atoms are drawn.'),
};
const Line = {
    /** Scales the corresponding visuals */
    size_factor: (0, field_schema_1.OptionalField)(field_schema_1.float, 1, 'Scales the corresponding visuals.'),
    /** Controls whether hydrogen atoms are drawn. */
    ignore_hydrogens: (0, field_schema_1.OptionalField)(field_schema_1.bool, false, 'Controls whether hydrogen atoms are drawn.'),
};
const Spacefill = {
    /** Scales the corresponding visuals */
    size_factor: (0, field_schema_1.OptionalField)(field_schema_1.float, 1, 'Scales the corresponding visuals.'),
    /** Controls whether hydrogen atoms are drawn. */
    ignore_hydrogens: (0, field_schema_1.OptionalField)(field_schema_1.bool, false, 'Controls whether hydrogen atoms are drawn.'),
};
const Carbohydrate = {
    /** Scales the corresponding visuals */
    size_factor: (0, field_schema_1.OptionalField)(field_schema_1.float, 1, 'Scales the corresponding visuals.'),
};
const Surface = {
    /** Type of surface representation. (Default is 'molecular') */
    surface_type: (0, field_schema_1.OptionalField)((0, field_schema_1.literal)('molecular', 'gaussian'), 'molecular', `Type of surface representation. (Default is 'molecular')`),
    /** Scales the corresponding visuals */
    size_factor: (0, field_schema_1.OptionalField)(field_schema_1.float, 1, 'Scales the corresponding visuals.'),
    /** Controls whether hydrogen atoms are drawn. */
    ignore_hydrogens: (0, field_schema_1.OptionalField)(field_schema_1.bool, false, 'Controls whether hydrogen atoms are drawn.'),
};
exports.MVSRepresentationParams = (0, params_schema_1.UnionParamsSchema)('type', 'Representation type', {
    cartoon: (0, params_schema_1.SimpleParamsSchema)(Cartoon),
    backbone: (0, params_schema_1.SimpleParamsSchema)(Backbone),
    ball_and_stick: (0, params_schema_1.SimpleParamsSchema)(BallAndStick),
    line: (0, params_schema_1.SimpleParamsSchema)(Line),
    spacefill: (0, params_schema_1.SimpleParamsSchema)(Spacefill),
    carbohydrate: (0, params_schema_1.SimpleParamsSchema)(Carbohydrate),
    surface: (0, params_schema_1.SimpleParamsSchema)(Surface),
});
const VolumeIsoSurface = {
    /** Relative isovalue. */
    relative_isovalue: (0, field_schema_1.OptionalField)((0, field_schema_1.nullable)(field_schema_1.float), null, 'Relative isovalue.'),
    /** Absolute isovalue. Overrides `relative_isovalue`. */
    absolute_isovalue: (0, field_schema_1.OptionalField)((0, field_schema_1.nullable)(field_schema_1.float), null, 'Absolute isovalue. Overrides `relative_isovalue`.'),
    /** Show mesh wireframe. Defaults to false. */
    show_wireframe: (0, field_schema_1.OptionalField)(field_schema_1.bool, false, 'Show mesh wireframe. Defaults to false.'),
    /** Show mesh faces. Defaults to true. */
    show_faces: (0, field_schema_1.OptionalField)(field_schema_1.bool, true, 'Show mesh faces. Defaults to true.'),
};
const VolumeGridSlice = {
    /** Dimension of the grid slice, i.e. 'x', 'y', or 'z'. */
    dimension: (0, field_schema_1.RequiredField)((0, field_schema_1.literal)('x', 'y', 'z'), 'Dimension of the grid slice, i.e. \'x\', \'y\', or \'z\'.'),
    /** Index of the grid slice in the specified dimension. 0-based index, i.e. 0 is the first slice. */
    absolute_index: (0, field_schema_1.OptionalField)((0, field_schema_1.nullable)(field_schema_1.int), null, 'Index of the grid slice in the specified dimension. 0-based index, i.e. 0 is the first slice.'),
    /** Relative index of the grid slice in the specified dimension. 0.0 is the first slice, 1.0 is the last slice. Overrides `absolute_index`. */
    relative_index: (0, field_schema_1.OptionalField)((0, field_schema_1.nullable)(field_schema_1.float), null, 'Relative index of the grid slice in the specified dimension. 0.0 is the first slice, 1.0 is the last slice. Overrides `absolute_index`.'),
    /** Relative isovalue. */
    relative_isovalue: (0, field_schema_1.OptionalField)((0, field_schema_1.nullable)(field_schema_1.float), null, 'Relative isovalue.'),
    /** Absolute isovalue. Overrides `relative_isovalue`. */
    absolute_isovalue: (0, field_schema_1.OptionalField)((0, field_schema_1.nullable)(field_schema_1.float), null, 'Absolute isovalue. Overrides `relative_isovalue`.'),
};
exports.MVSVolumeRepresentationParams = (0, params_schema_1.UnionParamsSchema)('type', 'Representation type', {
    'isosurface': (0, params_schema_1.SimpleParamsSchema)(VolumeIsoSurface),
    'grid_slice': (0, params_schema_1.SimpleParamsSchema)(VolumeGridSlice),
});
const ClipParamsBase = {
    /** Transformation matrix to applied to each point before clipping. For example, can be used to clip volumes in the grid/fractional space. Default is null. */
    check_transform: (0, field_schema_1.OptionalField)((0, field_schema_1.nullable)(param_types_1.Matrix), null, 'Transformation matrix to applied to each point before clipping. For example, can be used to clip volumes in the grid/fractional space. Default is null.'),
    /** Inverts the clipping region. Default is false. */
    invert: (0, field_schema_1.OptionalField)(field_schema_1.bool, false, 'Inverts the clipping region. Default is false'),
    /** Variant of the clip node, either "object" or "pixel". */
    variant: (0, field_schema_1.OptionalField)((0, field_schema_1.literal)('object', 'pixel'), 'pixel', 'Variant of the clip node, either "object" or "pixel"'),
};
exports.MVSClipParams = (0, params_schema_1.UnionParamsSchema)('type', 'Clip type', {
    plane: (0, params_schema_1.SimpleParamsSchema)({
        ...ClipParamsBase,
        /** Normal vector of the clipping plane. */
        normal: (0, field_schema_1.RequiredField)(param_types_1.Vector3, 'Normal vector of the clipping plane.'),
        /** Point on the clipping plane. */
        point: (0, field_schema_1.RequiredField)(param_types_1.Vector3, 'Point on the clipping plane.'),
    }),
    sphere: (0, params_schema_1.SimpleParamsSchema)({
        ...ClipParamsBase,
        /** Center of the clipping sphere. */
        center: (0, field_schema_1.RequiredField)(param_types_1.Vector3, 'Center of the clipping sphere.'),
        /** Radius of the clipping sphere. */
        radius: (0, field_schema_1.OptionalField)(field_schema_1.float, 1, 'Radius of the clipping sphere.'),
    }),
    box: (0, params_schema_1.SimpleParamsSchema)({
        ...ClipParamsBase,
        /** Center of the clipping box. */
        center: (0, field_schema_1.RequiredField)(param_types_1.Vector3, 'Center of the clipping box.'),
        /** Size of the clipping box. */
        size: (0, field_schema_1.OptionalField)(param_types_1.Vector3, [1, 1, 1], 'Size of the clipping box.'),
        /** Rotation matrix (3x3 matrix flattened in column major format (j*3+i indexing), this is equivalent to Fortran-order in numpy). This matrix will multiply the structure coordinates from the left. The default value is the identity matrix (corresponds to no rotation). */
        rotation: (0, field_schema_1.OptionalField)(param_types_1.Matrix, [1, 0, 0, 0, 1, 0, 0, 0, 1], 'Rotation matrix (3x3 matrix flattened in column major format (j*3+i indexing), this is equivalent to Fortran-order in numpy). This matrix will multiply the structure coordinates from the left. The default value is the identity matrix (corresponds to no rotation).'),
    }),
});
