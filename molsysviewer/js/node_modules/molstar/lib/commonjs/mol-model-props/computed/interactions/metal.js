"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 *
 * based in part on NGL (https://github.com/arose/ngl)
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetalCoordinationProvider = exports.MetalBindingProvider = exports.MetalProvider = exports.MetalCoordinationParams = void 0;
const param_definition_1 = require("../../../mol-util/param-definition.js");
const features_1 = require("./features.js");
const util_1 = require("../chemistry/util.js");
const types_1 = require("../../../mol-model/structure/model/properties/atomic/types.js");
const common_1 = require("./common.js");
const types_2 = require("../../../mol-model/structure/model/types.js");
exports.MetalCoordinationParams = {
    distanceMax: param_definition_1.ParamDefinition.Numeric(3.0, { min: 1, max: 5, step: 0.1 }),
};
const IonicTypeMetals = [
    types_1.Elements.LI, types_1.Elements.NA, types_1.Elements.K, types_1.Elements.RB, types_1.Elements.CS,
    types_1.Elements.MG, types_1.Elements.CA, types_1.Elements.SR, types_1.Elements.BA, types_1.Elements.AL,
    types_1.Elements.GA, types_1.Elements.IN, types_1.Elements.TL, types_1.Elements.SC, types_1.Elements.SN,
    types_1.Elements.PB, types_1.Elements.BI, types_1.Elements.SB, types_1.Elements.HG
];
function addMetal(structure, unit, builder) {
    const { elements } = unit;
    const { x, y, z } = unit.model.atomicConformation;
    for (let i = 0, il = elements.length; i < il; ++i) {
        const element = (0, util_1.typeSymbol)(unit, i);
        let type = common_1.FeatureType.None;
        if (IonicTypeMetals.includes(element)) {
            type = common_1.FeatureType.IonicTypeMetal;
        }
        else if ((0, types_1.isTransitionMetal)(element) || element === types_1.Elements.ZN || element === types_1.Elements.CD) {
            type = common_1.FeatureType.TransitionMetal;
        }
        if (type) {
            builder.add(type, common_1.FeatureGroup.None, x[elements[i]], y[elements[i]], z[elements[i]], i);
        }
    }
}
function isProteinSidechain(atomname) {
    return !types_2.ProteinBackboneAtoms.has(atomname);
}
function isProteinBackbone(atomname) {
    return types_2.ProteinBackboneAtoms.has(atomname);
}
function isNucleicBackbone(atomname) {
    return types_2.NucleicBackboneAtoms.has(atomname);
}
/**
 * Metal binding partners (dative bond or ionic-type interaction)
 */
function addMetalBinding(structure, unit, builder) {
    const { elements } = unit;
    const { x, y, z } = unit.model.atomicConformation;
    for (let i = 0, il = elements.length; i < il; ++i) {
        const element = (0, util_1.typeSymbol)(unit, i);
        const resname = (0, util_1.compId)(unit, i);
        const atomname = (0, util_1.atomId)(unit, i);
        let dative = false;
        let ionic = false;
        const isStandardAminoacid = types_2.AminoAcidNames.has(resname);
        const isStandardBase = types_2.BaseNames.has(resname);
        if (!isStandardAminoacid && !isStandardBase) {
            if ((0, types_1.isHalogen)(element) || element === types_1.Elements.O || element === types_1.Elements.S) {
                dative = true;
                ionic = true;
            }
            else if (element === types_1.Elements.N) {
                dative = true;
            }
        }
        else if (isStandardAminoacid) {
            // main chain oxygen atom or oxygen, nitrogen and sulfur from specific amino acids
            if (element === types_1.Elements.O) {
                if (['ASP', 'GLU', 'SER', 'THR', 'TYR', 'ASN', 'GLN'].includes(resname) && isProteinSidechain(atomname)) {
                    dative = true;
                    ionic = true;
                }
                else if (isProteinBackbone(atomname)) {
                    dative = true;
                    ionic = true;
                }
            }
            else if (element === types_1.Elements.S && (resname === 'CYS' || resname === 'MET')) {
                dative = true;
                ionic = true;
            }
            else if (element === types_1.Elements.N) {
                if (resname === 'HIS' && isProteinSidechain(atomname)) {
                    dative = true;
                }
            }
        }
        else if (isStandardBase) {
            // http://pubs.acs.org/doi/pdf/10.1021/acs.accounts.6b00253
            // http://onlinelibrary.wiley.com/doi/10.1002/anie.200900399/full
            if (element === types_1.Elements.O && isNucleicBackbone(atomname)) {
                dative = true;
                ionic = true;
            }
            else if (['N3', 'N4', 'N7'].includes(atomname)) {
                dative = true;
            }
            else if (['O2', 'O4', 'O6'].includes(atomname)) {
                dative = true;
                ionic = true;
            }
        }
        if (dative) {
            builder.add(common_1.FeatureType.DativeBondPartner, common_1.FeatureGroup.None, x[elements[i]], y[elements[i]], z[elements[i]], i);
        }
        if (ionic) {
            builder.add(common_1.FeatureType.IonicTypePartner, common_1.FeatureGroup.None, x[elements[i]], y[elements[i]], z[elements[i]], i);
        }
    }
}
function isMetalCoordination(ti, tj) {
    if (ti === common_1.FeatureType.TransitionMetal) {
        return (tj === common_1.FeatureType.DativeBondPartner ||
            tj === common_1.FeatureType.TransitionMetal);
    }
    else if (ti === common_1.FeatureType.IonicTypeMetal) {
        return (tj === common_1.FeatureType.IonicTypePartner);
    }
}
function testMetalCoordination(structure, infoA, infoB, distanceSq) {
    const typeA = infoA.types[infoA.feature];
    const typeB = infoB.types[infoB.feature];
    if (!isMetalCoordination(typeA, typeB) && !isMetalCoordination(typeB, typeA))
        return;
    return common_1.InteractionType.MetalCoordination;
}
//
exports.MetalProvider = features_1.Features.Provider([common_1.FeatureType.IonicTypeMetal, common_1.FeatureType.TransitionMetal], addMetal);
exports.MetalBindingProvider = features_1.Features.Provider([common_1.FeatureType.IonicTypePartner, common_1.FeatureType.DativeBondPartner], addMetalBinding);
exports.MetalCoordinationProvider = {
    name: 'metal-coordination',
    params: exports.MetalCoordinationParams,
    createTester: (props) => {
        return {
            maxDistance: props.distanceMax,
            requiredFeatures: new Set([common_1.FeatureType.IonicTypeMetal, common_1.FeatureType.TransitionMetal, common_1.FeatureType.IonicTypePartner, common_1.FeatureType.DativeBondPartner]),
            getType: (structure, infoA, infoB, distanceSq) => testMetalCoordination(structure, infoA, infoB, distanceSq)
        };
    }
};
