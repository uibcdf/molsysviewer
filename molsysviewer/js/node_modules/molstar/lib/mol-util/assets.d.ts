/**
 * Copyright (c) 2020-2025 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { UUID } from './uuid.js';
import { DataType, DataResponse } from './data-source.js';
import { Task } from '../mol-task/index.js';
export { AssetManager, Asset };
type _File = File;
type Asset = Asset.Url | Asset.File;
declare namespace Asset {
    type Url = {
        kind: 'url';
        id: UUID;
        url: string;
        title?: string;
        body?: string;
        headers?: [string, string][];
    };
    type File = {
        kind: 'file';
        id: UUID;
        name: string;
        file?: _File;
    };
    function Url(url: string, options?: {
        body?: string;
        title?: string;
        headers?: [string, string][];
    }): Url;
    function File(file: _File): File;
    function isUrl(x?: Asset): x is Url;
    function isFile(x?: Asset): x is File;
    interface Wrapper<T extends DataType = DataType> {
        readonly data: DataResponse<T>;
        dispose: () => void;
    }
    function Wrapper<T extends DataType = DataType>(data: DataResponse<T>, asset: Asset, manager: AssetManager): {
        data: DataResponse<T>;
        dispose: () => void;
    };
    function getUrl(url: string | Url): string;
    function getUrlAsset(manager: AssetManager, url: string | Url, body?: string): Url;
}
declare class AssetManager {
    private _assets;
    get assets(): {
        asset: Asset;
        file: File;
        refCount: number;
        isStatic?: boolean;
        tag?: string;
    }[];
    tryFindUrl(url: string, body?: string): Asset.Url | undefined;
    tryFindFilename(name: string): Asset | undefined;
    set(asset: Asset, file: File, options?: {
        isStatic?: boolean;
        tag?: string;
    }): void;
    get(asset: Asset): {
        asset: Asset;
        file: File;
        refCount: number;
        isStatic?: boolean;
        tag?: string;
    } | undefined;
    delete(asset: Asset): boolean;
    has(asset: Asset): boolean;
    resolve<T extends DataType>(asset: Asset, type: T, store?: boolean): Task<Asset.Wrapper<T>>;
    release(asset: Asset): void;
    clearTag(tag: string): void;
    clear(): void;
    dispose(): void;
}
