/**
 * Copyright (c) 2025 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
import { getJSONCifCategory } from '../../extensions/json-cif/model.js';
function padLeft(v, n = 3) {
    let s = `${v}`;
    while (s.length < n)
        s = ' ' + s;
    return s;
}
function padRight(v, n = 3) {
    let s = `${v}`;
    while (s.length < n)
        s = s + ' ';
    return s;
}
function mapMolChage(v) {
    switch (v) {
        case 3: return 1;
        case 2: return 2;
        case 1: return 3;
        case -1: return 5;
        case -2: return 6;
        case -3: return 7;
        default: return 0;
    }
}
function mapMolBondOrder(order, type) {
    if (type !== 'covale')
        return 8;
    switch (order) {
        case 'sing': return 1;
        case 'doub': return 2;
        case 'trip': return 3;
        case 'arom': return 4;
        default: return 8;
    }
}
export function jsonCifToMolfile(data, options) {
    // The method works in the sense that Mol* can re-open the file.
    // For production use, this will likely need more testing and tweaks (e.g., support for M CHG property).
    var _a, _b;
    if (data.categories.atom_site === undefined || data.categories.molstar_bond_site === undefined) {
        throw new Error('The data block must contain atom_site and molstar_bond_site categories.');
    }
    const { atom_site: _atoms, molstar_bond_site: _bonds } = data.categories;
    const atoms = getJSONCifCategory(data, 'atom_site');
    const bonds = getJSONCifCategory(data, 'molstar_bond_site');
    const lines = [
        `${(_a = options === null || options === void 0 ? void 0 : options.name) !== null && _a !== void 0 ? _a : 'mol'}`,
        '  Molstar           3D',
        (_b = options === null || options === void 0 ? void 0 : options.comment) !== null && _b !== void 0 ? _b : '',
        `${padLeft(atoms.rows.length)}${padLeft(bonds.rows.length)}  0  0  0  0  0  0  0  0 V2000`,
    ];
    const atomIdToIndex = new Map();
    for (let i = 0; i < atoms.rows.length; ++i) {
        const a = atoms.rows[i];
        const { id, Cartn_x, Cartn_y, Cartn_z, type_symbol, pdbx_formal_charge } = a;
        atomIdToIndex.set(id, i + 1);
        const fields = [
            padLeft(Cartn_x.toFixed(4), 10),
            padLeft(Cartn_y.toFixed(4), 10),
            padLeft(Cartn_z.toFixed(4), 10),
            ' ',
            padRight(type_symbol, 2),
            '  0',
            padLeft(mapMolChage(pdbx_formal_charge), 3),
            '  0  0  0  0  0  0  0  0  0  0',
        ];
        lines.push(fields.join(''));
    }
    for (const b of bonds.rows) {
        const { atom_id_1, atom_id_2, value_order, type_id } = b;
        const fields = [
            padLeft(atomIdToIndex.get(atom_id_1), 3),
            padLeft(atomIdToIndex.get(atom_id_2), 3),
            padLeft(mapMolBondOrder(value_order, type_id), 3),
            '  0  0  0  0',
        ];
        lines.push(fields.join(''));
    }
    lines.push('M  END');
    return lines.join('\n');
}
