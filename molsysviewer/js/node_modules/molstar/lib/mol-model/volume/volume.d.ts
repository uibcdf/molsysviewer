/**
 * Copyright (c) 2020-2025 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author David Sehnal <david.sehnal@gmail.com>
 */
import { Grid } from './grid.js';
import { OrderedSet } from '../../mol-data/int.js';
import { Box3D, Sphere3D } from '../../mol-math/geometry.js';
import { Mat4 } from '../../mol-math/linear-algebra.js';
import { ModelFormat } from '../../mol-model-formats/format.js';
import { CustomProperties } from '../custom-property.js';
import { ParamDefinition as PD } from '../../mol-util/param-definition.js';
export interface Volume {
    readonly label?: string;
    readonly entryId?: string;
    readonly grid: Grid;
    readonly instances: ReadonlyArray<{
        transform: Mat4;
    }>;
    readonly sourceData: ModelFormat;
    customProperties: CustomProperties;
    /**
     * Not to be accessed directly, each custom property descriptor
     * defines property accessors that use this field to store the data.
     */
    _propertyData: {
        [name: string]: any;
    };
    readonly colorVolume?: Volume;
}
export declare namespace Volume {
    function is(x: any): x is Volume;
    type CellIndex = {
        readonly '@type': 'cell-index';
    } & number;
    type InstanceIndex = {
        readonly '@type': 'instance-index';
    } & number;
    type SegmentIndex = {
        readonly '@type': 'segment-index';
    } & number;
    type IsoValue = IsoValue.Absolute | IsoValue.Relative;
    namespace IsoValue {
        type Relative = Readonly<{
            kind: 'relative';
            relativeValue: number;
        }>;
        type Absolute = Readonly<{
            kind: 'absolute';
            absoluteValue: number;
        }>;
        function areSame(a: IsoValue, b: IsoValue, stats: Grid['stats']): boolean;
        function absolute(value: number): Absolute;
        function relative(value: number): Relative;
        function calcAbsolute(stats: Grid['stats'], relativeValue: number): number;
        function calcRelative(stats: Grid['stats'], absoluteValue: number): number;
        function toAbsolute(value: IsoValue, stats: Grid['stats']): Absolute;
        function toRelative(value: IsoValue, stats: Grid['stats']): Relative;
        function toString(value: IsoValue): string;
    }
    function adjustedIsoValue(volume: Volume, value: number, kind: 'absolute' | 'relative'): Readonly<{
        kind: "absolute";
        absoluteValue: number;
    }> | Readonly<{
        kind: "relative";
        relativeValue: number;
    }>;
    function createIsoValueParam(defaultValue: Volume.IsoValue, stats?: Grid['stats']): PD.Conditioned<Readonly<{
        kind: "absolute";
        absoluteValue: number;
    }> | Readonly<{
        kind: "relative";
        relativeValue: number;
    }>, PD.Base<Readonly<{
        kind: "absolute";
        absoluteValue: number;
    }> | Readonly<{
        kind: "relative";
        relativeValue: number;
    }>>, {
        absolute: PD.Converted<Readonly<{
            kind: "absolute";
            absoluteValue: number;
        }>, number>;
        relative: PD.Converted<Readonly<{
            kind: "relative";
            relativeValue: number;
        }>, number>;
    }>;
    const IsoValueParam: PD.Conditioned<Readonly<{
        kind: "absolute";
        absoluteValue: number;
    }> | Readonly<{
        kind: "relative";
        relativeValue: number;
    }>, PD.Base<Readonly<{
        kind: "absolute";
        absoluteValue: number;
    }> | Readonly<{
        kind: "relative";
        relativeValue: number;
    }>>, {
        absolute: PD.Converted<Readonly<{
            kind: "absolute";
            absoluteValue: number;
        }>, number>;
        relative: PD.Converted<Readonly<{
            kind: "relative";
            relativeValue: number;
        }>, number>;
    }>;
    type IsoValueParam = typeof IsoValueParam;
    const One: Volume;
    function areEquivalent(volA: Volume, volB: Volume): boolean;
    function areInstanceTransformsEqual(volA: Volume, volB: Volume): boolean;
    function isEmpty(vol: Volume): boolean;
    function isOrbitals(volume: Volume): boolean;
    interface Loci {
        readonly kind: 'volume-loci';
        readonly volume: Volume;
        readonly instances: OrderedSet<InstanceIndex>;
    }
    function Loci(volume: Volume, instances: OrderedSet<InstanceIndex>): Loci;
    function isLoci(x: any): x is Loci;
    function areLociEqual(a: Loci, b: Loci): boolean;
    function isLociEmpty(loci: Loci): boolean;
    function getBoundingSphere(volume: Volume, boundingSphere?: Sphere3D): Sphere3D;
    namespace Isosurface {
        interface Loci {
            readonly kind: 'isosurface-loci';
            readonly volume: Volume;
            readonly isoValue: Volume.IsoValue;
            readonly instances: OrderedSet<InstanceIndex>;
        }
        function Loci(volume: Volume, isoValue: Volume.IsoValue, instances: OrderedSet<InstanceIndex>): Loci;
        function isLoci(x: any): x is Loci;
        function areLociEqual(a: Loci, b: Loci): boolean;
        function isLociEmpty(loci: Loci): boolean;
        function getBoundingSphere(volume: Volume, isoValue: Volume.IsoValue, boundingSphere?: Sphere3D): Sphere3D;
    }
    namespace Cell {
        interface Loci {
            readonly kind: 'cell-loci';
            readonly volume: Volume;
            readonly elements: ReadonlyArray<{
                readonly indices: OrderedSet<CellIndex>;
                readonly instances: OrderedSet<InstanceIndex>;
            }>;
        }
        function Loci(volume: Volume, elements: Loci['elements']): Loci;
        function isLoci(x: any): x is Loci;
        function areLociEqual(a: Loci, b: Loci): boolean;
        function isLociEmpty(loci: Loci): boolean;
        function getLociSize(loci: Loci): number;
        interface Location {
            readonly kind: 'cell-location';
            volume: Volume;
            cell: CellIndex;
            instance: InstanceIndex;
        }
        function Location(volume?: Volume, cell?: CellIndex, instance?: InstanceIndex): Location;
        function isLocation(x: any): x is Location;
        function getBoundingSphere(volume: Volume, elements: Loci['elements'], boundingSphere?: Sphere3D): Sphere3D;
    }
    namespace Segment {
        interface Loci {
            readonly kind: 'segment-loci';
            readonly volume: Volume;
            readonly elements: ReadonlyArray<{
                readonly segments: OrderedSet<SegmentIndex>;
                readonly instances: OrderedSet<InstanceIndex>;
            }>;
        }
        function Loci(volume: Volume, elements: Loci['elements']): Loci;
        function isLoci(x: any): x is Loci;
        function areLociEqual(a: Loci, b: Loci): boolean;
        function isLociEmpty(loci: Loci): boolean;
        function getLociSize(loci: Loci): number;
        function getBoundingSphere(volume: Volume, elements: Loci['elements'], boundingSphere?: Sphere3D): Sphere3D;
        interface Location {
            readonly kind: 'segment-location';
            volume: Volume;
            segment: SegmentIndex;
            instance: InstanceIndex;
        }
        function Location(volume?: Volume, segment?: number, instance?: InstanceIndex): Location;
        function isLocation(x: any): x is Location;
    }
    type PickingGranularity = 'volume' | 'object' | 'voxel';
    const PickingGranularity: {
        set(volume: Volume, granularity: PickingGranularity): void;
        get(volume: Volume): PickingGranularity;
    };
    type Segmentation = {
        segments: Map<Volume.SegmentIndex, Set<number>>;
        sets: Map<number, Set<Volume.SegmentIndex>>;
        bounds: {
            [k: Volume.SegmentIndex]: Box3D;
        };
        labels: {
            [k: Volume.SegmentIndex]: string;
        };
    };
    const Segmentation: {
        set(volume: Volume, segmentation: Segmentation): void;
        get(volume: Volume): Segmentation | undefined;
    };
}
